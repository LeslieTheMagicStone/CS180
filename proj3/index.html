<!DOCTYPE html>
<html>
<head>
    <title>Project 3: (Auto)stitching and Photo Mosaics</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="./style.css">
</head>
<body>
    <div class="container">
        <h1>Project 3</h1>

        <h2>Part A.1: Shoot the Pictures</h2>
        <p>I used my phone to take three sets of overlapping photos.</p>

        <img src="./images/haas_images.jpg" alt="Haas courtyard photos">
        <img src="./images/outdoor_images.jpg" alt="Outside window photos">
        <img src="./images/kt_images.jpg" alt="Kitchen photos">

        <h2>Part A.2: Recovering Homographies</h2>
        <p>Before any warping or mosaicing, I needed the homography <em>H</em> that maps a point <code>p = [x, y, 1]^T</code> in image 1 to its correspondence <code>p' = [x', y', 1]^T</code> in image 2 via <code>p' ~ H p</code>. Because <em>H</em> has eight degrees of freedom (the (3,3) entry can be fixed to 1), every correspondence gives me two linear equations. Stacking <em>n</em> correspondences yields the familiar DLT design matrix <em>A</em>:</p>

        <pre><code>[-x  -y  -1   0   0   0   xx'  yx'  x']
[ 0   0   0  -x  -y  -1   xy'  yy'  y']
[h1 h2 h3 h4 h5 h6 h7 h8 h9]^T = 0
        </code></pre>

        <p>With <em>n</em> ≥ 4 correspondences the system is overdetermined, so, following the DLT recipe, I solve <code>A h = 0</code> in the least-squares sense by taking the right-singular vector corresponding to the smallest singular value.</p>

        <p>The plots below are the correspondences I manually selected using the online tool made by a prior student (<a href="https://cal-cs180.github.io/fa23/hw/proj3/tool.html" target="_blank" rel="noopener">https://cal-cs180.github.io/fa23/hw/proj3/tool.html</a>).</p>

        <img src="./images/haas_correspondences.jpg" alt="Haas courtyard correspondences">
        <img src="./images/outdoor_correspondences.jpg" alt="Outdoor plaza correspondences">
        <img src="./images/kt_correspondences.jpg" alt="Kitchen correspondences">

        <p>After solving for <em>H</em> I validated each solution. I projected the image-1 points through <em>H</em> and computed the reprojection error <code>||H p - p'||_2</code>. The statistics are tiny, confirming the least-squares fit is stable.</p>

        <table>
            <thead>
                <tr>
                    <th>Pair</th>
                    <th>Homography H</th>
                    <th>Mean reprojection error (px)</th>
                    <th>Max error (px)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Haas courtyard</td>
                    <td><code>[1.56, -0.15, -610.03]<br>[0.52, 1.39, -490.95]<br>[4.3e-4, 1.6e-5, 1]</code></td>
                    <td>2.07</td>
                    <td>5.01</td>
                </tr>
                <tr>
                    <td>View outside my window</td>
                    <td><code>[1.44, 0.081, -633.44]<br>[0.22, 1.26, -144.63]<br>[3.5e-4, -8.9e-6, 1]</code></td>
                    <td>2.00</td>
                    <td>4.34</td>
                </tr>
                <tr>
                    <td>Kitchen</td>
                    <td><code>[1.71, -0.045, -950.19]<br>[0.46, 1.53, -507.11]<br>[4.9e-4, 5.3e-5, 1]</code></td>
                    <td>1.43</td>
                    <td>3.49</td>
                </tr>
            </tbody>
        </table>

        <h2>Part A.3: Warp the Images</h2>
        <p>Then I implemented inverse warping in two flavors. Both <code>warpImageNearestNeighbor</code> and <code>warpImageBilinear</code> pre-compute the canvas bounds by pushing the source image corners through <em>H</em>, loop over every integer pixel on that canvas, pull back through <code>H<sup>-1</sup></code>, and sample the source only when the back-projected coordinate lands inside the image bounds. The functions also return an alpha mask so later blending steps can reason about valid pixels.</p>

        <p>Below are two examples comparing the interpolation schemes. The qualities are similar, but the bilinear versions preserve fine details slightly better (e.g., the “Entry 3” text of the Haas picture), at the cost of roughly doubling the runtime.</p>

        <img src="./images/warp_haas_comparison.jpg" alt="Haas warp comparison">
        <img src="./images/warp_outdoor_comparison.jpg" alt="Outdoor warp comparison">

        <p>Here are the timings:</p>
        <table>
            <thead>
                <tr>
                    <th>Example</th>
                    <th>Nearest (ms)</th>
                    <th>Bilinear (ms)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Haas courtyard</td>
                    <td>7,420</td>
                    <td>14,708</td>
                </tr>
                <tr>
                    <td>View out of my window</td>
                    <td>7,205</td>
                    <td>14,031</td>
                </tr>
            </tbody>
        </table>

        <h3>Rectification</h3>
        <p>To validate that the warps behave outside of pairwise stitching, I rectified two single images. Using the same point-selection tool, I clicked the four corners of a planar patch (top-left, top-right, bottom-left, bottom-right). For each set of points I built a rectangle whose width and height match the average of the opposing side lengths, solved <code>computeH(pts_quad, target_rect)</code>, and warped the image with both methods.</p>

        <img src="./images/rect_ctbd.jpg" alt="Countertop cutting board rectification">
        <img src="./images/rect_fish.jpg" alt="Fish market menu rectification">

        <p>Both tests worked well.</p>

        <p>Here are the timings:</p>
        <table>
            <thead>
                <tr>
                    <th>Example</th>
                    <th>Nearest (ms)</th>
                    <th>Bilinear (ms)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Cutting-board</td>
                    <td>9,883</td>
                    <td>19,112</td>
                </tr>
                <tr>
                    <td>Filet-O-Fish</td>
                    <td>8,431</td>
                    <td>15,263</td>
                </tr>
            </tbody>
        </table>

        <h2>Part A.4: Blend the Images into a Mosaic</h2>
        <p>For the mosaics I kept the rightmost picture fixed and inverse-warped the leftmost picture to that canvas. Every warp returns an image plus an alpha map describing where the transform landed inside bounds. I convert those sparse alphas into smooth weight fields with <code>feather_alpha_dt</code> (a distance transform capped at 100 px), so each pixel's contribution tapers off toward image borders. Summing <code>image * weight</code> across the stack and dividing by the accumulated weights produces a seamless blend without hard seams.
        For image warping, I used nearest neighbor interpolation for better speed with reasonable quality.</p>

        <h3>Haas courtyard</h3>
        <img src="./images/mosaic_haas.jpg" alt="Haas courtyard sources and mosaic">

        <h3>View outside my window</h3>
        <img src="./images/mosaic_window.jpg" alt="Window view sources and mosaic">

        <h3>Kitchen</h3>
        <img src="./images/mosaic_kt.jpg" alt="Kitchen sources and mosaic">

        <p>Across all three examples the weighted average handles both sky gradients and textured surfaces well. The only noticeable artifacts are minor lighting level differences between the views, resulting from automatic exposure adjustments between shots.</p>
        <h2>Part B.1: Harris Corner Detection</h2>
        <p>To find potential points, I used the Harris corner detector, as provided in the starter code. The function returns the local maximum points of "corner strength". Here are the raw Harris corners detected on two images before any filtering:</p>
        <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:center; justify-content:flex-start;">
            <div style="text-align:center;">
                <img src="./images/haas1_harris_all.png" alt="Harris raw 1" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">haas1</div>
            </div>
            <div style="text-align:center;">
                <img src="./images/haas2_harris_all.png" alt="Harris raw 2" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">haas2</div>
            </div>
        </div>
        <p>Wow! That was scary. Those raw Harris output contained so many corners, and was not effective for robust matching later on. So I applied a threshold to the corner strength (0.01 times the maximum corner strength) to filter out some weak corners. Here are the filtered Harris corners:</p>
        <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:center; justify-content:flex-start;">
            <div style="text-align:center;">
                <img src="./images/haas1_harris_strong_corners.png" alt="Harris filtered 1" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">haas1</div>
            </div>
            <div style="text-align:center;">
                <img src="./images/haas2_harris_strong_corners.png" alt="Harris filtered 2" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">haas2</div>
            </div>
        </div>
        <p>However, after the thresholding, the strong corners might be clustered together. So I applied ANMS to select well-distributed corners. For each corner, ANMS computes a suppression radius. The point that has no stronger neighbors has infinite radius. For other points, the radius is the distance to the nearest corner that has a significantly higher corner strength. Finally, it selects the top N points with the largest suppression radius. Here are the corners selected by ANMS:</p>
        <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:center; justify-content:flex-start;">
            <div style="text-align:center;">
                <img src="./images/haas1_harris_anms.png" alt="Harris ANMS 1" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">haas1</div>
            </div>
            <div style="text-align:center;">
                <img src="./images/haas2_harris_anms.png" alt="Harris ANMS 2" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">haas2</div>
            </div>
        </div>
        <p>After those steps, I obtained a fairly evenly distributed set of strong corners.</p>

        <h2>Part B.2: Feature Descriptor Extraction</h2>
        <p>To match the corners, I still needed a way to describe each corner. For each corner, I extracted a 40x40 patch centered at the corner, blurred it to make the descriptor more robust, and downsampled it to an 8x8 patch. Finally, I normalized the descriptor to make it robust to simple brightness and contrast changes. Here are some example patches extracted from the corners:</p>
        <img src="./images/haas2_sampled_descriptor_points.png" alt="Feature points">
        <img src="./images/haas_descriptors_visualization.png" alt="Feature patches">

        <h2>Part B.3: Feature Matching</h2>
        <p>Now we can match those descriptors! I measured the similarity between two descriptors using the L2 distance. I implemented a symmetric version of Lowe's ratio test to filter out ambiguous matches. For each descriptor in image 1, I found its two nearest neighbors in image 2. If the ratio of the distances to the nearest and second nearest neighbor is below a threshold, I accepted the match. I repeated the same process for each descriptor in image 2. Finally, I only kept the matches that were accepted in both directions. Here are the matches found between two images:</p>
        <img src="./images/haas_matches_initial.png" alt="Feature matches">

        <h2>Part B.4: RANSAC for Robust Homography</h2>
        <p>As we can see, there are still some mismatches in the previous results due to repetitive patterns and noise. So I implemented RANSAC to find a robust homography that fits the inliers (correct matches) while ignoring the outliers (incorrect matches). I iteratively did the following: First, randomly select 4 distinct matches to compute a candidate homography. Then, I projected all the corners from image 1 to image 2 and calculated the squared Euclidean distance between the projected points and their corresponding points in image 2. Then I counted how many matches have a squared distance below a threshold, which are considered inliers. If the number of inliers is larger than the best one found so far, I updated the best homography and inlier set. After a fixed number of iterations, I re-computed the homography using all the inliers found for the best homography. Here are the inlier (green) and outlier (red) matches after RANSAC:</p>
        <img src="./images/haas_matches_inliers_outliers.png" alt="RANSAC inliers and outliers">
        <p>Finally, I used the computed homography to warp and blend the two images into a mosaic. Here are the final auto stitching results vs the manual stitching results on three image pairs:</p>
        <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:center; justify-content:flex-start; margin-bottom:12px;">
            <div style="text-align:center;">
                <img src="./images/haas_auto_mosaic.png" alt="Auto 1" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">haas auto</div>
            </div>
            <div style="text-align:center;">
                <img src="./images/haas_manual_mosaic.jpg" alt="Manual 1" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">haas manual</div>
            </div>
        </div>
        <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:center; justify-content:flex-start; margin-bottom:12px;">
            <div style="text-align:center;">
                <img src="./images/desk_auto_mosaic.png" alt="Auto 2" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">desk auto</div>
            </div>
            <div style="text-align:center;">
                <img src="./images/desk_manual_mosaic.jpg" alt="Manual 2" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">desk manual</div>
            </div>
        </div>
        <div style="display:flex; gap:16px; flex-wrap:wrap; align-items:center; justify-content:flex-start; margin-bottom:12px;">
            <div style="text-align:center;">
                <img src="./images/boxes_auto_mosaic.png" alt="Auto 3" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">boxes auto</div>
            </div>
            <div style="text-align:center;">
                <img src="./images/boxes_manual_mosaic.jpg" alt="Manual 3" style="max-width:320px; height:auto;">
                <div style="font-size:0.95em; margin-top:4px;">boxes manual</div>
            </div>
        </div>
    </div>
</body>
</html>